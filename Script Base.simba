program merch;

{$Define SMART8}
{$i SRL/SRL.simba}
{$i SRL/SRL/misc/Grandexchange.simba}
{$i SRL/SRL/misc/Online.simba}


{==============================================================================}
{==========                       INSTRUCTIONS                       ==========}
{==============================================================================}
{==========                        Merchanter                        ==========}
{==============================================================================}
{==========        1. Fill out all the information below.             =========}
{==========        2.                                                 =========}
{==========        3.                                                 =========}
{==========        4.                                                 =========}
{==========        5.                                                 =========}
{==============================================================================}
{==============================================================================}
type MerchingInfo = record
  Name: string;
  Buyprice, SellPrice, Slot, GeLimit: Integer;
end;

const
  MinProfitPerFlip = 100000; //min amount to make per flip

var
  FlippingItems: array[0..4] of MerchingInfo;

procedure LoadBarInfo;
begin
  with FlippingItems[0] do
  begin
    Name := 'Iron Ore';
    GeLimit := 25000;
  end;

  with FlippingItems[1] do
  begin
    Name := 'ItemName';
    GeLimit := 10000;
  end;

  with FlippingItems[2] do
  begin
    Name := 'ItemName';
    GeLimit := 10000;
  end;

  with FlippingItems[4] do
  begin
    Name := 'ItemName';
    GeLimit := 10000;
  end;
end;

procedure DeclarePlayers;
begin
  HowManyPlayers := 1;
  NumberOfPlayers(HowManyPlayers);
  CurrentPlayer := 0;
  with Players[0] do
  begin
    Name       := '';                 //login in name
    Pass       := '';                //Password
    Pin        := '';           // Leave blank if you don't have one
    Active     := True;
  end;
end;

function HighLow(index: integer): boolean;//Returns successful.  edits FlippingItem[index] for found values
var
  Buyprice, SellPrice, Margin, ProfitPerFlip, spot: Integer;
begin
  Result:= False;//default   , don't need this? - killer
  if(not GEFindFreeSpot(spot))then
  begin
    WriteLn('All current GE spots are taken.');
    Exit;
  end;
  BuyPrice := GetGEPrice(FlippingItems[index].Name);
  BuyPrice := Round(BuyPrice * 1.2);
  GEBuy(FlippingItems[index].Name, IntToStr(BuyPrice), '1');    //Buying Item
  Wait(5000);

  if GEFinishedAt(spot) then
  begin
    MouseTBox(GESpotToTbox(spot), mouse_left); // checks if it's finished
  end else
  begin
    Writeln('Item didnt buy at 20% over ge price, aborting...');
    GERecoverAtEx(spot, True);
    Exit;
  end;

  Wait(2000);

  BuyPrice := StrToInt(GetNumbers(GetTextAtExWrap(131, 286, 344, 300, 0, 50, 10, 39372, 5, 'StatChars')));
  Writeln('Buy Price ' + IntToStr(BuyPrice));   //Writing buying Price
  FlippingItems[index].Sellprice:= BuyPrice;
  GEMenuExit;            //Exiting Menu (Seems buggy, read it.  Has NO randomness at all.  I may rewrite some of the functions in there)
  GEREcoverAt(spot);        //Getting the Item
  GeSell('1', '1', 1);       //Selling Item
  Wait(1000);

  if GEFinishedAt(spot) then
  begin
    MouseTBox(GESpotToTbox(spot), mouse_left); // checks if it's finished
  end else
  begin
    writeln('Couldnt sell at 1gp - useless. Aborting...');
    GERecoverAtEx(spot, True);
    Exit;
  end;

  Wait(2000);
  SellPrice := StrToInt(GetNumbers(GetTextAtExWrap(131, 286, 344, 300, 0, 50, 10, 39372, 5, 'StatChars')))
  FlippingItems[index].BuyPrice:= SellPrice;
  Writeln('Sell Price' + IntToStr(SellPrice))     //Writes selling price
  GEMenuExit;                   //exiting menu
  Wait(2000);
  GERecoverAt(1);               //getting my precious money
  Margin := BuyPrice - SellPrice
  Writeln('Margin: ' + IntToStr(Margin)) // that's the high low
  ProfitPerFlip := Margin * FlippingItems[index].GeLimit;

  If ProfitPerFlip >= MinProfitPerFlip then
  begin
    Result:= True;
  end else
  begin
    Writeln('Profit Per Flip is less than Min Profit Per Flip');
  end;
end;

procedure FlipItem(index: integer);
var
  x: integer;
begin
  x:= 0;
  GEBuy(FlippingItems[index].Name, IntToStr(FlippingItems[index].BuyPrice), IntToStr(FlippingItems[index].GELimit - 1));    //Buying Item
  wait(15000);//If not done in 15 seconds, do other stuff for half hour.  That logic will need to be off a timer and exist elsewhere I think
  if(GEFinishedAt(FlippingItems[index].slot))then//Bought all, so sell
  begin
    GeSell(IntToStr(FlippingItems[index].SellPrice), 'all', 1);       //Selling Item
  end else begin

  end;

  {
  if x=300 then//half an hour and not done
    GERecoverAtEx(FlippingItems[index].spot, True);
   }

end;

//By Bandland100, modified by Ashaman88 to shift mouse speeds after every step
//
procedure SuperWindMouse(xs, ys, xe, ye, gravity, wind, minWait, maxWait, maxStep, targetArea: extended);
var
  veloX,veloY,windX,windY,veloMag,dist,randomDist,lastDist,step: extended;
  lastX,lastY,MSP,W: integer;
  sqrt2,sqrt3,sqrt5: extended;
begin
  MSP  := MouseSpeed;
  sqrt2:= sqrt(2);
  sqrt3:= sqrt(3);
  sqrt5:= sqrt(5);
  while hypot(xs - xe, ys - ye) > 1 do
  begin
    dist:= hypot(xs - xe, ys - ye);
    wind:= minE(wind, dist);
    if dist >= targetArea then
    begin
      windX:= windX / sqrt3 + (random(round(wind) * 2 + 1) - wind) / sqrt5;
      windY:= windY / sqrt3 + (random(round(wind) * 2 + 1) - wind) / sqrt5;
    end else
    begin
      windX:= windX / sqrt2;
      windY:= windY / sqrt2;
      if (maxStep < 3) then
      begin
        maxStep:= random(3) + 3.0;
      end else
      begin
        maxStep:= maxStep / sqrt5;
      end;
    end;
    veloX:= veloX + windX;
    veloY:= veloY + windY;
    veloX:= veloX + gravity * (xe - xs) / dist;
    veloY:= veloY + gravity * (ye - ys) / dist;
    if hypot(veloX, veloY) > maxStep then
    begin
      randomDist:= maxStep / 2.0 + random(round(maxStep) div 2);
      veloMag:= sqrt(veloX * veloX + veloY * veloY);
      veloX:= (veloX / veloMag) * randomDist;
      veloY:= (veloY / veloMag) * randomDist;
    end;
    lastX:= Round(xs);
    lastY:= Round(ys);
    xs:= xs + veloX;
    ys:= ys + veloY;

    case Random(50) of
      1..25: W := (MSP + (Random((MSP/4))));
      26..50: W := (MSP - (RandomRange((MSP/2), MSP-1)));
    end;
    if (W < 1) then
      W := 1;

    if (lastX <> Round(xs)) or (lastY <> Round(ys)) then
      MoveMouse(Round(xs), Round(ys));

    step:= hypot(xs - lastX, ys - lastY);
    //W := round((maxWait - minWait) * (step / maxStep) + minWait);
    wait(W);
    lastdist:= dist;
  end;

  if (Round(xe) <> Round(xs)) or (Round(ye) <> Round(ys)) then
    MoveMouse(Round(xe), Round(ye));

  MouseSpeed := MSP;
end;

Procedure HumanMMouse(eX, eY, ranX, ranY: Integer);
var
  randSpeed: extended;
  X,Y,X2,Y2,j,Dist,MP: integer;
begin
  j := MouseSpeed;
  GetMousePos(X, Y);
  Dist := Distance(X, Y, eX, eY);
  MP := Round(Dist/150);
  if MP < 0 then
    MP := 1;

  randSpeed := (random(MouseSpeed) / 2.0 + MouseSpeed) / 10.0;
  X2 := RandomRange(eX-(j*MP), eX+(j*MP));
  Y2 := RandomRange(eY-(j*MP), eY+(j*MP));
  SuperWindMouse(X, Y, X2, Y2, 11, 8, 10.0 / randSpeed, 12.0 / randSpeed, 10.0 * randSpeed, 10.0 * randSpeed);
  GetMousePos(X, Y);
  MMouse(eX, eY, ranX, ranY);
  MouseSpeed := j;
end;

{*******************************************************************************
procedure FastClick(button: Integer);
By: Flight
Description: Quickly click the mouse.
*******************************************************************************}
procedure FastClick(button: variant);
var
  x, y: integer;
  ibutton: Integer;
begin
  if VariantIsBoolean(button) then
  begin
    if (button) then
      iButton := mouse_left
    else
      iButton := mouse_right;
  end else
    iButton := button;

  if (iButton = mouse_move) then Exit;
  GetMousePos(x, y);
  HoldMouse(x, y, iButton);

  Wait(RandomRange(60, 150));

  GetMousePos(x, y);
  ReleaseMouse(x, y, iButton);
end;

Procedure HumanMouseBox(X1, Y1, X2, Y2: Integer);
    Var
      FX, FY: Integer;
    Begin
      GaussBox(FX,FY,X1,Y1,X2,Y2);
      HumanMMouse(FX,FY,0,0)
    End;



//////////////////////////////////////////////////////////////////////////////////////////////

begin
  ClearDebug;
  SRL_SixHourFix := True;
  SMART_FixSpeed := True;
  SetupSRL;
  LoadBarInfo;
  DeclarePlayers;
  LoginPlayer;
  if(HighLow(0))then
    FlipItem(0);
end.
